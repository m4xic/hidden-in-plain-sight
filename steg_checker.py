from pattern import pattern_offset as po
import argparse
from lsb import read_binary_from_image as read_lsb
import exif
import os
from PIL import Image
from zipfile import ZipFile, BadZipFile

def exif_check(source_folder, files=None):
    # Can either be passed a list of files or just list the files in the source folder
    if files == None: files = os.listdir(source_folder)
    # For each file...
    for file in files:
        # Get the full relative path
        path = os.path.join(source_folder, file)
        # Open the image and check the width and height
        width, height = Image.open(path).size
        # Use the file variable as a preview name for which file is being processed, shorten the name for display
        if len(file) > 16: file = file[:4] + '(...)' + file.split('.')[0][-3:] + '.' + file.split('.')[-1] 
        print(f"[EXIF] Processing {file}... ({width}x{height}, {width*height} pixels)")
        # Open the image using the exif library
        exif_image = exif.Image(path)
        # If the image has no EXIF data...
        if not exif_image.has_exif:
            # Print an error
            print(f"[EXIF] No EXIF metadata found in {file}... skipping.\n")
        # If the image has no 'artist' tag...
        elif exif_image.get('artist') is None:
            # Print an error
            print(f"[EXIF] No artist tag found in {file}.\n")
        # Otherwise, if the artist tag is present
        else:
            try:
                # Check if the full artist tag value is a valid string generated by pattern_create
                offset = po(exif_image.get('artist'), length=1000000)
                print(f"[EXIF] {file} has VALID EXIF metdata! Offset: {offset}, length {len(exif_image.get('artist'))}\n")
            except:
                # pattern_offset will raise an exception if the string is not fully valid
                print(f"[EXIF] {file} does not have valid artist metadata. Check the EXIF tag.\n")

def lsb_check(source_folder, files=None):
    # Can either be passed a list of files or just list the files in the source folder
    if files == None: files = os.listdir(source_folder)
    # For each file...
    for file in files:
        # Get the full relative path
        path = os.path.join(source_folder, file)
        # Open the image and check the width and height
        width, height = Image.open(path).size
        # Use the file variable as a preview name for which file is being processed, shorten the name for display
        if len(file) > 16: file = file[:4] + '(...)' + file.split('.')[0][-3:] + '.' + file.split('.')[-1] 
        print(f"[LSB] Processing {file}... ({width}x{height}, {width*height} pixels)")
        # Use the LSB module to try and read an LSB message
        lsb_result = read_lsb(path)
        # If no message found
        if lsb_result is None:
            # Print an error
            print(f"[LSB] No LSB message found.\n")
        else:
            # If a message was found, check if it was valid
            print(f"[LSB] LSB message found: {lsb_result[:4]}...{lsb_result[-4:]}")
            try:
                offset = po(lsb_result, length=1000000)
                print(f"[LSB] {file} has a VALID LSB message! Offset: {offset}, length {len(lsb_result)}\n")
            except:
                # pattern_offset will raise an exception if the string is not fully valid
                print(f"[LSB] The message found was not valid. Maybe it got corrupted?\n")

def zip_check(source_folder, files=None):
    # Can either be passed a list of files or just list the files in the source folder
    if files == None: files = os.listdir(source_folder)
    # For each file...
    for file in files:
        # Get the full relative path
        path = os.path.join(source_folder, file)
        # Open the image and check the width and height
        width, height = Image.open(path).size
        # Use the file variable as a preview name for which file is being processed, shorten the name for display
        if len(file) > 16: file = file[:4] + '(...)' + file.split('.')[0][-3:] + '.' + file.split('.')[-1] 
        print(f"[ZIP] Processing {file}... ({width}x{height}, {width*height} pixels)")
        try:
            # Try opening the file using ZipFile (will raise an exception if invalid)
            zip_file = ZipFile(path)
            # testzip() checks the CRC hashes and ensures the zip file is intact
            zip_file.testzip()
            print(f"[ZIP] Looks like a valid ZIP file!")
        except BadZipFile:
            print(f"[ZIP] This doesn\'t look like a valid ZIP file.")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Check to see if the tested steganographic footprint is present')
    # Allow input of exactly one image file
    parser.add_argument('mode', metavar='M', type=str, help='(d)ct, (e)xif, (l)sb, (z)ip or (a)ll')
    # Allow input of exactly one output folder
    parser.add_argument('source_folder', metavar='S', type=str, help='the folder containing the images')
    # Parse the command line arguments
    args = parser.parse_args()

    files = os.listdir(args.source_folder)

    if args.mode.lower().startswith('d'):
        print("[!] Use OutGuess manually.")
    elif args.mode.lower().startswith('e'):
        exif_check(args.source_folder, files)
    elif args.mode.lower().startswith('l'):
        lsb_check(args.source_folder, files)
    elif args.mode.lower().startswith('z'):
        zip_check(args.source_folder, files)
    elif args.mode.lower().startswith('a'):
        methods = {"exif": exif_check, "lsb": lsb_check, "zip": zip_check}
        #for website in ["facebook", "flickr", "gphotos", "tumblr", "twitter"]:
        for website in ["twitter"]:
            print(f"[!] Starting {website} processing.")
            for method in methods.keys():
                for size in ["large", "medium", "small"]:
                    print(f"[!] Current size is {size}")
                    source_folder = args.source_folder + 'websites\\' + website + '\\' + method + '\\' + size
                    files = os.listdir(source_folder)
                    methods[method](source_folder, files)
    else:
        print("[!] Invalid option supplied for mode.")